## 一、黑名单的初始创建

### 1.1.声明阶段

```solidity
// PEPE.sol 第12行
mapping(address => bool) public blacklists;    // 黑名单映射,默认值为false
```

- **关键点**：
  - 这是一个**状态变量声明**
  - 在合约部署时自动创建
  - 不需要在构造函数中初始化
  - `Mapping`本身不占用存储槽位,但会分配一个槽位用于存储映射的"根"



### 1.2.`Mapping`的存储机制

#### A.`Mapping`的存储布局

```
合约账户 Storage
  ├── Slot 0: limited (bool)
  ├── Slot 1: maxHoldingAmount (uint256)
  ├── Slot 2: minHoldingAmount (uint256)
  ├── Slot 3: uniswapV2Pair (address)
  └── Slot 4: blacklists mapping 的"根"位置
      └── (不存储实际数据,只作为映射的起始点)
```



#### B.`Mapping`键值对的存储位置

```
blacklists[address] 的实际存储位置：
= keccak256(abi.encodePacked(address, slot))
= keccak256(abi.encodePacked(address, 4))

例如：
blacklists[0xABC...] 存储在: keccak256(0xABC... + 4)
blacklists[0xDEF...] 存储在: keccak256(0xDEF... + 4)
```



### 1.3.`Mapping`的默认值机制

#### A.`Solidity Mapping`的默认值规则

在`Solidity`中,所有`mapping`的键值对默认值都是**类型的零值**：

| 类型 | 零值 |
|------|------|
| `bool` | `false` |
| `uint256` | `0` |
| `address` | `address(0)` |
| `string` | `""` (空字符串) |



#### B.黑名单`Mapping`的默认值

```solidity
mapping(address => bool) public blacklists;
```

- **默认行为**：
  - 任何未设置的地址,`blacklists[address]` 返回 `false`
  - 这意味着**所有地址默认都不在黑名单中**
  - 不需要显式初始化



#### C.实际示例

```solidity
// 部署合约后,未设置任何黑名单
address user = 0x123...;

// 读取未设置的地址
bool isBlacklisted = blacklists[user];
// 返回: false (默认值)

// 检查黑名单
require(!blacklists[user], "Blacklisted");
// 通过检查,因为 false 取反为 true
```



## 二、黑名单的添加机制

### 2.1.添加函数

```solidity
// PEPE.sol 第18-20行
function blacklist(address _address, bool _isBlacklisting) external onlyOwner {
    blacklists[_address] = _isBlacklisting;
}
```



### 2.2.添加流程详解

#### A.步骤1：函数调用

```
owner 调用: blacklist(0xABC..., true)
  ↓
onlyOwner 修饰符检查
  ↓
检查: owner() == msg.sender ?
  ↓
通过检查(假设是 owner)
```



#### B.步骤2：写入`Storage`

```solidity
blacklists[_address] = _isBlacklisting;
```

- **执行过程**：

```
1. 计算存储位置：
   storageSlot = keccak256(abi.encodePacked(0xABC..., 4))
   = 0x1234...5678 (哈希值)

2. 写入 Storage：
   Storage[0x1234...5678] = true

3. 更新状态树：
   将修改写入以太坊状态树
```



#### C.步骤3：`Gas`消耗

```
SSTORE 操作：
- 首次写入(从零值到非零值): 20,000 Gas
- 修改已存在的值: 5,000 Gas
- 从非零值改为零值: 退款 15,000 Gas
```



### 2.3.添加地址到黑名单

#### A.示例：添加地址到黑名单

```solidity
// owner 调用
blacklist(0xBadAddress..., true);

// 执行结果：
blacklists[0xBadAddress...] = true

// 存储位置：
storageLocation = keccak256(abi.encodePacked(0xBadAddress..., slot4))
Storage[storageLocation] = true
```



#### B.执行后的状态

```
部署前：
blacklists[0xBadAddress...] = false (默认值,未实际存储)

添加后：
blacklists[0xBadAddress...] = true (实际存储在 Storage 中)
```



### 2.4.从黑名单移除地址

#### A.示例：从黑名单移除地址

```solidity
// owner 调用
blacklist(0xBadAddress..., false);

// 执行结果：
blacklists[0xBadAddress...] = false

// 存储位置：
storageLocation = keccak256(abi.encodePacked(0xBadAddress..., slot4))
Storage[storageLocation] = false
```



#### B.执行后的状态

```
移除前：
blacklists[0xBadAddress...] = true (存储在 Storage 中)

移除后：
blacklists[0xBadAddress...] = false (存储在 Storage 中,但值已改变)
```

**注意**：即使设置为 `false`,这个键值对仍然存在于`Storage`中,只是值为 `false`.如果需要完全清除(节省`Gas`),可以使用 `delete` 操作.



## 三、完整的生命周期

### 3.1.合约部署阶段

```
部署交易执行
  ↓
创建合约账户
  ↓
初始化状态变量
  ├── limited = false
  ├── maxHoldingAmount = 0
  ├── minHoldingAmount = 0
  ├── uniswapV2Pair = address(0)
  └── blacklists = {} (空映射,所有地址默认返回 false)
  ↓
执行构造函数
  ↓
部署完成
```



### 3.2.黑名单添加阶段

```
owner 调用 blacklist(0xABC..., true)
  ↓
onlyOwner 检查通过
  ↓
计算存储位置: keccak256(0xABC... + slot4)
  ↓
写入 Storage: Storage[位置] = true
  ↓
更新状态树
  ↓
完成：0xABC... 已被添加到黑名单
```



### 3.3.黑名单检测阶段

```
用户发起转账
  ↓
_beforeTokenTransfer() 被调用
  ↓
读取 blacklists[from]
  ├── 如果从未设置 → 返回 false (默认值)
  ├── 如果设置为 true → 返回 true
  └── 如果设置为 false → 返回 false
  ↓
读取 blacklists[to]
  ├── 如果从未设置 → 返回 false (默认值)
  ├── 如果设置为 true → 返回 true
  └── 如果设置为 false → 返回 false
  ↓
检查: require(!blacklists[from] && !blacklists[to], "Blacklisted")
  ↓
如果任一地址在黑名单中 → 交易被拒绝
如果两个地址都不在黑名单中 → 交易继续
```



## 四、存储优化技巧

### 4.1.使用 `delete`操作清除映射

```solidity
// 方式1：设置为 false (仍然占用 Storage)
blacklist(0xABC..., false);

// 方式2：使用 delete 清除(释放 Storage,获得 Gas 退款)
delete blacklists[0xABC...];
```



- **区别**：

| 操作 | Storage 状态 | Gas 消耗 | 读取结果 |
|------|-------------|---------|---------|
| `blacklists[addr] = false` | 仍然存储 `false` | 5,000 Gas | `false` |
| `delete blacklists[addr]` | 清除存储 | 退款 15,000 Gas | `false` (默认值) |

**注意**：虽然 `delete` 后读取结果都是 `false`,但 `delete` 可以释放`Storage`并获得`Gas`退款.



### 4.2.批量操作优化

- **不好的方式：逐个调用函数**

```solidity
// PEPE合约中已有的函数
function blacklist(address _address, bool _isBlacklisting) external onlyOwner {
    blacklists[_address] = _isBlacklisting;
}

// 不好的方式：批量添加时调用函数
function addMultipleBlacklist(address[] memory addresses) external onlyOwner {
    for (uint i = 0; i < addresses.length; i++) {
        blacklist(addresses[i], true);  // ← 这里调用blacklist()函数
    }
}
```

- 问题：

  - 每次循环都调用`blacklist()`函数

  - 每次调用都有函数调用开销(函数选择器、参数编码等)

  - `Gas`消耗更高：`N`个地址 = `N`次函数调用开销



- **好的方式：直接写入存储**

```solidity
// PEPE合约中已有的函数
function blacklist(address _address, bool _isBlacklisting) external onlyOwner {
    blacklists[_address] = _isBlacklisting;
}

// 好的方式：批量添加时直接写入存储
function addMultipleBlacklist(address[] memory addresses) external onlyOwner {
    for (uint i = 0; i < addresses.length; i++) {
        blacklists[addresses[i]] = true;  // ← 这里直接写入blacklists映射
    }
}
```

**关键点：`blacklists[addresses[i]] = true`是直接写入存储映射**



- **区别说明**

| 特性       | 方式一（调用函数）            | 方式二（直接写入）              |
| :--------- | :---------------------------- | :------------------------------ |
| 代码       | blacklist(addresses[i], true) | blacklists[addresses[i]] = true |
| 操作       | 调用 blacklist() 函数         | 直接访问 blacklists 映射        |
| Gas消耗    | 更高（每次调用有函数开销）    | 更低（只有存储写入）            |
| 函数选择器 | 需要（0x...）                 | 不需要                          |
| 参数编码   | 需要编码参数                  | 不需要                          |

### 





## 五、实际应用示例

### 5.1.完整的黑名单管理流程

```solidity
// 1. 部署合约
PepeToken token = new PepeToken(1000000 * 10**18);
// blacklists 映射已创建,所有地址默认不在黑名单中

// 2. 添加地址到黑名单
token.blacklist(0xBadAddress..., true);
// blacklists[0xBadAddress...] = true

// 3. 检查地址是否在黑名单中
bool isBlacklisted = token.blacklists(0xBadAddress...);
// 返回: true

// 4. 该地址尝试转账(会被拒绝)
token.transfer(0xBadAddress..., 1000);
// _beforeTokenTransfer 检查: !true = false
// require(false, "Blacklisted") → 交易被拒绝

// 5. 从黑名单移除地址
token.blacklist(0xBadAddress..., false);
// blacklists[0xBadAddress...] = false

// 6. 该地址再次尝试转账(允许)
token.transfer(0xBadAddress..., 1000);
// _beforeTokenTransfer 检查: !false = true
// require(true, "Blacklisted") → 交易通过
```



### 5.2.批量管理黑名单

```solidity
// 扩展函数：批量添加黑名单
function batchBlacklist(
    address[] memory addresses,
    bool _isBlacklisting
) external onlyOwner {
    for (uint i = 0; i < addresses.length; i++) {
        blacklists[addresses[i]] = _isBlacklisting;
    }
}

// 使用示例
address[] memory badAddresses = new address[](3);
badAddresses[0] = 0xAAA...;
badAddresses[1] = 0xBBB...;
badAddresses[2] = 0xCCC...;

batchBlacklist(badAddresses, true);
// 一次性添加多个地址到黑名单
```



## 6.存储位置验证

### 6.1.查看黑名单状态

```javascript
// 使用 ethers.js
const contract = await PepeToken.attach(contractAddress);

// 读取特定地址的黑名单状态
const isBlacklisted = await contract.blacklists("0xABC...");
console.log("Is blacklisted:", isBlacklisted);  // true 或 false
```



### 6.2.直接读取`Storage`

```javascript
// 计算存储位置
const address = "0xABC...";
const slot = 4; // blacklists mapping 的槽位

// 编码地址和槽位
const encoded = ethers.utils.solidityKeccak256(
    ["address", "uint256"],
    [address, slot]
);

// 读取 Storage
const storageValue = await provider.getStorageAt(contractAddress, encoded);
// 如果返回 "0x0000...0001" → true
// 如果返回 "0x0000...0000" → false 或未设置
```



## 7.总结

### 7.1.黑名单初始创建

- **1.声明阶段**：
  - 通过 `mapping(address => bool) public blacklists;` 声明
  - 在合约部署时自动创建
  - 不需要在构造函数中初始化
- **2.默认值机制**：
  - 所有未设置的地址默认返回 `false`
  - 意味着所有地址默认都不在黑名单中
  - `Mapping`的键值对按需创建(懒加载)
- **3.存储机制**：
  - `Mapping`本身不占用连续存储槽位
  - 每个键值对存储在哈希计算的位置
  - 存储位置 = `keccak256(abi.encodePacked(key, slot))`



### 7.2.黑名单添加机制

- **1.添加函数**：
  - `blacklist(address _address, bool _isBlacklisting)`
  - 只有`owner`可以调用(`onlyOwner` 修饰符)
  - 直接写入 Storage: `blacklists[_address] = _isBlacklisting`
- **2.添加流程**：

```
函数调用 → 权限检查 → 计算存储位置 → 写入 Storage → 更新状态树
```

- **3.`Gas`消耗**：
  - 首次写入: 20,000 `Gas`
  - 修改值: 5,000 `Gas`
  - 清除存储: 退款 15,000 `Gas`



### 7.3.关键理解

- **初始创建**：通过声明状态变量自动完成,无需手动初始化
- **默认值**：所有地址默认不在黑名单中(`false`)
- **添加方式**：通过 `blacklist()` 函数手动添加
- **存储位置**：使用哈希计算,按需创建
- **检测机制**：在 `_beforeTokenTransfer` 中读取 mapping 值进行检测



## 八、相关代码位置

- **PEPE.sol**：
  - 黑名单声明：第12行
  
  ```solidity
      mapping(address => bool) public blacklists;    // 黑名单映射,默认值为false
  ```
  
  
  
  - 添加函数：第18-20行
  
  ```solidity
      function blacklist(address _address, bool _isBlacklisting) external onlyOwner {
          blacklists[_address] = _isBlacklisting;     // 设置黑名单状态,如果日志为true,则表示地址在黑名单中,如果日志为false,则表示地址不在黑名单中
      }
  ```
  
  
  
  - 检测位置：第34行
  
  ```solidity
          require(!blacklists[to] && !blacklists[from], "Blacklisted");  // 接收方和发送发都是false,则表示接收方和发送方都不在黑名单中,所以允许交易
  ```
  
  
  
- **相关文档**：
  
  - `02-onlyOwner修饰符与黑名单机制详解-辅助参考.md`
  - `06-构造函数执行结果的存储机制.md`

