package main

import (
	"fmt"
	"sync"
	"time"
)

// producer 生产者协程：生成1到10的整数并发送到通道
func producer(ch chan<- int, wg *sync.WaitGroup) {
	defer wg.Done()
	defer close(ch) // 关闭通道，通知消费者没有更多数据

	fmt.Println("生产者协程启动，开始生成数据...")

	for i := 1; i <= 10; i++ {
		fmt.Printf("生产者发送: %d\n", i)
		ch <- i // 发送数据到通道
		time.Sleep(100 * time.Millisecond)
	}

	fmt.Println("生产者协程完成，已发送所有数据")
}

// consumer 消费者协程：从通道接收整数并打印
func consumer(ch <-chan int, wg *sync.WaitGroup) {
	defer wg.Done()

	fmt.Println("消费者协程启动，开始接收数据...")

	for value := range ch {
		fmt.Printf("消费者接收: %d\n", value)
		time.Sleep(150 * time.Millisecond)
	}

	fmt.Println("消费者协程完成，通道已关闭")
}

func main() {
	fmt.Println("=== Go语言通道通信示例 ===")
	fmt.Println()

	// 创建无缓冲通道
	ch := make(chan int)

	// 创建WaitGroup用于同步协程
	var wg sync.WaitGroup

	// 启动生产者协程
	wg.Add(1)
	go producer(ch, &wg)

	// 启动消费者协程
	wg.Add(1)
	go consumer(ch, &wg)

	// 等待所有协程完成
	wg.Wait()

	fmt.Println("\n=== 程序执行完毕 ===")
}
