## 1.问题分析

### 1.1.函数定义

```solidity
// PEPE.sol 第22-27行
function setRule(bool _limited, address _uniswapV2Pair, uint256 _maxHoldingAmount, uint256 _minHoldingAmount) external onlyOwner {
    limited = _limited;
    uniswapV2Pair = _uniswapV2Pair;
    maxHoldingAmount = _maxHoldingAmount;
    minHoldingAmount = _minHoldingAmount;
}
```



### 1.2.状态变量定义

```solidity
// PEPE.sol 第8-11行
bool public limited;                    // 是否启用持币限制,默认值为false
uint256 public maxHoldingAmount;        // 最大持币量,默认值为0
uint256 public minHoldingAmount;        // 最小持币量,默认值为0
address public uniswapV2Pair;          // Uniswap V2 交易对地址,默认值为address(0)
```



## 二、关键概念区分

### 2.1.函数参数`vs`状态变量

| 类型 | 名称 | 作用域 | 生命周期 | 存储位置 |
|------|------|--------|---------|---------|
| **函数参数** | `_limited`, `_uniswapV2Pair`, `_maxHoldingAmount`, `_minHoldingAmount` | 函数内部 | 函数执行期间 | 内存(Memory)或栈(Stack) |
| **状态变量** | `limited`, `uniswapV2Pair`, `maxHoldingAmount`, `minHoldingAmount` | 合约全局 | 合约生命周期 | 链上存储(Storage) |



## 三、详细执行流程

### 3.1.函数调用过程

```
owner 调用: setRule(true, 0xABC..., 1000, 100)
  ↓
onlyOwner 修饰符检查
  ↓
通过检查
  ↓
函数参数传入:
  _limited = true
  _uniswapV2Pair = 0xABC...
  _maxHoldingAmount = 1000
  _minHoldingAmount = 100
  ↓
执行函数体:
  limited = _limited;                    // limited = true
  uniswapV2Pair = _uniswapV2Pair;        // uniswapV2Pair = 0xABC...
  maxHoldingAmount = _maxHoldingAmount;   // maxHoldingAmount = 1000
  minHoldingAmount = _minHoldingAmount;   // minHoldingAmount = 100
  ↓
写入 Storage:
  Storage[limited的槽位] = true
  Storage[uniswapV2Pair的槽位] = 0xABC...
  Storage[maxHoldingAmount的槽位] = 1000
  Storage[minHoldingAmount的槽位] = 100
  ↓
函数执行完成
  ↓
函数参数(_limited等)被销毁(局部变量)
  ↓
状态变量(limited等)永久保存在链上
```



### 3.2.参数传递方式

#### A.是的,参数值需要通过参数形式传入

```solidity
// 调用示例
setRule(
    true,              // _limited 参数
    0xABC...,          // _uniswapV2Pair 参数
    1000,              // _maxHoldingAmount 参数
    100                // _minHoldingAmount 参数
);
```

- **关键点**：
  - 所有参数值必须通过函数调用时传入
  - 参数是局部变量,只在函数执行期间存在
  - 参数值会被赋给状态变量



## 四、状态变量的持久化

### 4.1.函数执行后的状态

#### A.函数参数不会成为全局变量

- **函数参数**：
  - 不是全局变量
  - 只在函数执行期间存在
  - 函数执行完成后被销毁
  - 存储在内存或栈中,不持久化



#### B.状态变量是全局的,会持久化

- **状态变量**：
  - 是全局变量(合约级别)
  - 在合约整个生命周期内存在
  - 函数执行完成后仍然存在
  - 存储在链上`Storage`中,永久保存



### 4.2.执行前后对比

#### A.执行前

```
状态变量(Storage):
  limited = false
  uniswapV2Pair = address(0)
  maxHoldingAmount = 0
  minHoldingAmount = 0

函数参数(不存在):
  _limited = (不存在)
  _uniswapV2Pair = (不存在)
  _maxHoldingAmount = (不存在)
  _minHoldingAmount = (不存在)
```



#### B.函数执行中

```
状态变量(Storage):
  limited = false (准备更新)
  uniswapV2Pair = address(0) (准备更新)
  maxHoldingAmount = 0 (准备更新)
  minHoldingAmount = 0 (准备更新)

函数参数(内存中):
  _limited = true (传入的参数)
  _uniswapV2Pair = 0xABC... (传入的参数)
  _maxHoldingAmount = 1000 (传入的参数)
  _minHoldingAmount = 100 (传入的参数)
```



#### C.执行后

```
状态变量(Storage - 已更新):
  limited = true (已更新,永久保存)
  uniswapV2Pair = 0xABC... (已更新,永久保存)
  maxHoldingAmount = 1000 (已更新,永久保存)
  minHoldingAmount = 100 (已更新,永久保存)

函数参数(已销毁):
  _limited = (已销毁)
  _uniswapV2Pair = (已销毁)
  _maxHoldingAmount = (已销毁)
  _minHoldingAmount = (已销毁)
```



## 五、存储位置详解

### 5.1.函数参数的存储

```solidity
function setRule(bool _limited, address _uniswapV2Pair, uint256 _maxHoldingAmount, uint256 _minHoldingAmount) external onlyOwner {
    // 参数存储在:
    // - 基本类型(bool, uint256, address): 存储在栈(Stack)中
    // - 复杂类型(数组,结构体): 存储在内存(Memory)中
}
```

- **存储位置**：
  - **栈(Stack)**：用于存储基本类型的参数
  - **内存(Memory)**：用于存储复杂类型的参数
  - **特点**：函数执行完成后自动释放



### 5.2.状态变量的存储

```solidity
bool public limited;                    // Storage Slot 0
uint256 public maxHoldingAmount;        // Storage Slot 1
uint256 public minHoldingAmount;        // Storage Slot 2
address public uniswapV2Pair;          // Storage Slot 3
```

- **存储位置**：
  - **Storage(链上存储)**：永久保存在区块链上
  - **特点**：合约生命周期内一直存在



## 六、实际应用示例

### 6.1.完整的调用流程

```javascript
// 使用 ethers.js 调用
const contract = await PepeToken.attach(contractAddress);

// 1. 查看当前状态(执行前)
const limitedBefore = await contract.limited();
console.log("limited (before):", limitedBefore);  // false

const maxHoldingBefore = await contract.maxHoldingAmount();
console.log("maxHoldingAmount (before):", maxHoldingBefore.toString());  // 0

// 2. 调用函数,传入参数
const tx = await contract.setRule(
    true,              // _limited 参数
    "0xABC...",        // _uniswapV2Pair 参数
    ethers.parseEther("1000"),  // _maxHoldingAmount 参数
    ethers.parseEther("100")   // _minHoldingAmount 参数
);

await tx.wait();  // 等待交易确认

// 3. 查看更新后的状态(执行后)
const limitedAfter = await contract.limited();
console.log("limited (after):", limitedAfter);  // true 

const maxHoldingAfter = await contract.maxHoldingAmount();
console.log("maxHoldingAmount (after):", maxHoldingAfter.toString());  // 1000 * 10^18 

// 4. 参数变量已不存在(无法访问)
// _limited, _uniswapV2Pair 等参数变量已销毁
// 但状态变量 limited, uniswapV2Pair 等仍然存在并可访问
```



### 6.2.状态变量的持久性验证

```javascript
// 即使函数执行完成很久之后,状态变量仍然可以访问
const limited = await contract.limited();  // 仍然返回 true
const uniswapV2Pair = await contract.uniswapV2Pair();  // 仍然返回 0xABC...

// 参数变量无法访问(已不存在)
// 无法访问 _limited, _uniswapV2Pair 等参数变量
```



## 7.变量作用域对比

### 7.1.函数参数的作用域

```solidity
function setRule(bool _limited, address _uniswapV2Pair, uint256 _maxHoldingAmount, uint256 _minHoldingAmount) external onlyOwner {
    // 函数参数只能在这个函数内部访问
    // 函数执行完成后,参数变量被销毁
    // 函数外部无法访问参数变量
    
    limited = _limited;  // 可以访问参数
    // ...
}

function anotherFunction() external {
    // 无法访问 setRule 函数的参数
    // _limited 不存在
    // 但可以访问状态变量
    bool currentLimited = limited;  // 可以访问状态变量
}
```



### 7.2.状态变量的作用域

```solidity
contract PepeToken {
    bool public limited;  // 全局状态变量
    
    function setRule(...) external onlyOwner {
        limited = _limited;  // 可以访问状态变量
    }
    
    function _beforeTokenTransfer(...) internal virtual {
        if (limited && from == uniswapV2Pair) {  // 可以访问状态变量
            // ...
        }
    }
    
    function anotherFunction() external {
        bool currentLimited = limited;  // 可以访问状态变量
    }
}
```



## 8.内存`vs`存储

### 8.1.函数参数(内存)

```
函数调用
  ↓
参数值传入内存/栈
  ↓
函数执行
  ↓
参数值赋给状态变量
  ↓
函数执行完成
  ↓
参数变量被销毁(内存释放)
```

- **特点**：
  - 临时存储
  - 函数执行完成后自动释放
  - 不消耗持久化存储`Gas`



### 8.2.状态变量(存储)

```
函数执行
  ↓
参数值赋给状态变量
  ↓
写入 Storage
  ↓
更新状态树
  ↓
永久保存在链上
```

- **特点**：
  - 永久存储
  - 合约生命周期内一直存在
  - 消耗`Storage Gas`(20,000 `Gas`首次写入,5,000 `Gas`修改)



## 九、`Gas`消耗分析

### 9.1.函数参数`Gas`消耗

```solidity
function setRule(bool _limited, address _uniswapV2Pair, uint256 _maxHoldingAmount, uint256 _minHoldingAmount) external onlyOwner {
    // 参数传递: 几乎不消耗 Gas(calldata 读取)
    // 参数存储: 不消耗 Storage Gas(存储在内存/栈中)
}
```

- **Gas 消耗**：
  - 参数传递：~100-200 `Gas`(`calldata`读取)
  - 参数存储：0 `Gas`(内存/栈存储)



### 9.2.状态变量`Gas`消耗

```solidity
limited = _limited;                    // SSTORE: 20,000 Gas (首次) 或 5,000 Gas (修改)
uniswapV2Pair = _uniswapV2Pair;        // SSTORE: 20,000 Gas (首次) 或 5,000 Gas (修改)
maxHoldingAmount = _maxHoldingAmount; // SSTORE: 20,000 Gas (首次) 或 5,000 Gas (修改)
minHoldingAmount = _minHoldingAmount; // SSTORE: 20,000 Gas (首次) 或 5,000 Gas (修改)
```

- **Gas 消耗**：
  - 首次写入：20,000 Gas × 4 = 80,000 Gas
  - 修改值：5,000 Gas × 4 = 20,000 Gas



## 十、总结

### 10.1.关键理解

- **1.参数值需要通过参数形式传入**：

  - 是的,所有参数值必须通过函数调用时传入
  - 参数是局部变量,只在函数执行期间存在

- **2.函数参数不会成为全局变量**：

  - 函数参数不是全局变量
  - 函数执行完成后参数变量被销毁
  - 但参数值会被写入状态变量,状态变量是全局的

- **3.状态变量是全局的,会持久化**：

  - 状态变量是合约级别的全局变量
  - 函数执行完成后仍然存在
  - 永久保存在链上`Storage`中

  

### 10.2.执行流程总结

```
调用函数 → 参数传入 → 参数值赋给状态变量 → 写入 Storage → 函数完成 → 参数销毁 → 状态变量保留
```



### 10.3.变量对比表

| 特性 | 函数参数 | 状态变量 |
|------|---------|---------|
| **作用域** | 函数内部 | 合约全局 |
| **生命周期** | 函数执行期间 | 合约生命周期 |
| **存储位置** | 内存/栈 | Storage(链上) |
| **持久化** | 不持久化 | 永久保存 |
| **Gas 消耗** | 低(~100-200) | 高(5,000-20,000) |
| **可访问性** | 仅函数内部 | 合约内任何地方 |



### 10.4.重要结论

**函数参数值需要通过参数形式传入,函数执行完成后参数变量会被销毁,但参数值会被写入状态变量,状态变量是全局的,会永久保存在链上.**



## 十一、相关代码位置

- **状态变量声明**：PEPE.sol 第8-11行

```solidity
    bool public limited;    // 是否启用持币限制,默认值为false
    uint256 public maxHoldingAmount;    // 最大持币量,默认值为0
    uint256 public minHoldingAmount;    // 最小持币量,默认值为0
    address public uniswapV2Pair;    // Uniswap V2 交易对地址,默认值为address(0)
```



- **函数定义**：PEPE.sol 第22-27行

```solidity
    function setRule(bool _limited, address _uniswapV2Pair, uint256 _maxHoldingAmount, uint256 _minHoldingAmount) external onlyOwner {
        limited = _limited;
        uniswapV2Pair = _uniswapV2Pair;
        maxHoldingAmount = _maxHoldingAmount;
        minHoldingAmount = _minHoldingAmount;
    }
```



- **状态变量使用**：PEPE.sol 第36行,第41行,第42行

```solidity
        if (uniswapV2Pair == address(0)) {  // 表示交易对尚未创建,只有合约所有者可以进行交易
        
        
       if (limited && from == uniswapV2Pair) {  // 检查是否启用持币限制
       
       require(super.balanceOf(to) + amount <= maxHoldingAmount && super.balanceOf(to) + amount >= minHoldingAmount, "Forbid");  // 如果接收方总余额超过最大持币量或小于最小持币量,则抛出错误
```



## 十二、相关概念

- **函数参数**：函数调用时传入的局部变量
- **状态变量**：合约级别的全局变量,存储在链上
- **Storage**：链上持久化存储
- **Memory**：临时内存存储
- **Stack**：执行栈,用于存储基本类型
- **Gas 消耗**：执行操作所需的费用

