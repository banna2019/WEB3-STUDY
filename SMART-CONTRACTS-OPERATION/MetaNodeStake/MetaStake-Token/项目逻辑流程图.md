# MetaStake-Token项目逻辑流程图

本文档详细描述了`MetaStake-Token`质押系统的核心逻辑流程

## 一、目录

- 1.[系统架构概览](#系统架构概览)
- 2.[部署流程](#部署流程)
- 3.[质押流程](#质押流程)
- 4.[解质押流程](#解质押流程)
- 5.[领取奖励流程](#领取奖励流程)
- 6.[Uniswap交换流程](#uniswap交换流程)
- 7.[奖励分配机制](#奖励分配机制)
- 8.[池管理流程](#池管理流程)
- 9.[合约升级流程](#合约升级流程)
- 10.[紧急操作流程](#紧急操作流程)



## 二、系统架构概览

```mermaid
graph TB
    A[用户] -->|质押/解质押/领取| B[MetaStake合约]
    B -->|存储| C[质押池Pool]
    B -->|奖励| D[MetaNode代币]
    B -->|交换| E[Uniswap Router]
    E -->|交换| F[ETH/其他代币]
    
    G[管理员] -->|管理| B
    G -->|添加池| C
    G -->|配置| B
    
    H[部署账户] -->|部署| I[MetaNodeToken]
    H -->|部署| B
    H -->|铸造| D
    
    style B fill:#e1f5ff
    style C fill:#fff4e1
    style D fill:#e8f5e9
    style E fill:#f3e5f5
```



## 三、部署流程

```mermaid
sequenceDiagram
    participant Admin as 管理员
    participant DeployScript as 部署脚本
    participant MetaNodeToken as MetaNode代币
    participant MetaStake as MetaStake合约
    participant Proxy as UUPS代理
    
    Admin->>DeployScript: 运行部署脚本
    DeployScript->>MetaNodeToken: 部署MetaNode代币
    MetaNodeToken-->>DeployScript: 返回代币地址
    
    DeployScript->>Proxy: 部署UUPS代理
    Proxy->>MetaStake: 部署实现合约
    MetaStake-->>Proxy: 返回实现地址
    Proxy-->>DeployScript: 返回代理地址
    
    DeployScript->>MetaStake: initialize(代币地址, 奖励/区块, 开始区块, 管理员)
    MetaStake->>MetaStake: 设置角色和权限
    
    DeployScript->>MetaNodeToken: mint(奖励总量)到MetaStake合约
    MetaNodeToken-->>DeployScript: 铸造完成
    
    DeployScript->>MetaStake: addPool(ETH池)
    MetaStake-->>DeployScript: 池创建成功
    
    opt 如果配置了Uniswap Router
        DeployScript->>MetaStake: setUniswapRouter(Router地址)
        MetaStake-->>DeployScript: Router设置成功
    end
    
    DeployScript->>DeployScript: 更新.env文件
    DeployScript->>DeployScript: 保存部署信息到JSON
    DeployScript-->>Admin: 部署完成
```



## 四、质押流程

```mermaid
flowchart TD
    A[用户发起质押] --> B{检查暂停状态}
    B -->|已暂停| C[交易失败: Staking is paused]
    B -->|未暂停| D{检查池是否存在}
    D -->|不存在| E[交易失败: Pool does not exist]
    D -->|存在| F{检查质押数量}
    F -->|低于最小值| G[交易失败: Amount below minimum]
    F -->|符合要求| H[调用updatePool更新池奖励]
    
    H --> I{用户已有质押?}
    I -->|是| J[计算并累积待领取奖励]
    I -->|否| K[跳过奖励计算]
    
    J --> L{质押代币类型}
    K --> L
    
    L -->|Native Currency ETH| M[检查msg.value == amount]
    L -->|ERC20代币| N[检查msg.value == 0]
    
    M -->|不匹配| O[交易失败: Incorrect ETH amount]
    M -->|匹配| P[更新用户质押数量]
    
    N -->|有ETH| Q[交易失败: ETH not needed]
    N -->|无ETH| R[从用户转移ERC20代币到合约]
    R --> P
    
    P --> S[更新池总质押量]
    S --> T[更新用户finishedMetaNode]
    T --> U[发出Staked事件]
    U --> V[质押成功]
    
    style V fill:#c8e6c9
    style C fill:#ffcdd2
    style E fill:#ffcdd2
    style G fill:#ffcdd2
    style O fill:#ffcdd2
    style Q fill:#ffcdd2
```



## 五、解质押流程

```mermaid
flowchart TD
    A[用户发起解质押] --> B{检查暂停状态}
    B -->|已暂停| C[交易失败: Unstaking is paused]
    B -->|未暂停| D{检查池是否存在}
    D -->|不存在| E[交易失败: Pool does not exist]
    D -->|存在| F{检查解质押数量}
    F -->|超过质押数量| G[交易失败: Insufficient balance]
    F -->|符合要求| H[调用updatePool更新池奖励]
    
    H --> I[计算并累积待领取奖励]
    I --> J[减少用户质押数量]
    J --> K[减少池总质押量]
    K --> L[计算解锁区块号]
    L --> M[创建解质押请求UnstakeRequest]
    M --> N[添加到用户请求列表]
    N --> O[发出Unstaked事件]
    O --> P[解质押请求成功]
    
    P --> Q[等待锁定期]
    Q --> R{锁定期是否结束?}
    R -->|否| S[继续等待]
    R -->|是| T[用户可以调用withdraw提取]
    
    style P fill:#fff9c4
    style T fill:#c8e6c9
    style C fill:#ffcdd2
    style E fill:#ffcdd2
    style G fill:#ffcdd2
```



## 六、领取奖励流程

```mermaid
flowchart TD
    A[用户发起领取奖励] --> B{检查暂停状态}
    B -->|已暂停| C[交易失败: Claiming is paused]
    B -->|未暂停| D{检查池是否存在}
    D -->|不存在| E[交易失败: Pool does not exist]
    D -->|存在| F[调用updatePool更新池奖励]
    
    F --> G[计算用户待领取奖励]
    G --> H{有可领取奖励?}
    H -->|无| I[不执行任何操作]
    H -->|有| J[计算总奖励 = pendingReward + 新累积奖励]
    
    J --> K[清零用户pendingMetaNode]
    K --> L[更新用户finishedMetaNode]
    L --> M[从合约转移MetaNode代币给用户]
    M --> N[发出Claimed事件]
    N --> O[领取成功]
    
    style O fill:#c8e6c9
    style I fill:#fff9c4
    style C fill:#ffcdd2
    style E fill:#ffcdd2
```



## 七、Uniswap交换流程

```mermaid
sequenceDiagram
    participant User as 用户
    participant MetaStake as MetaStake合约
    participant MetaNodeToken as MetaNode代币
    participant UniswapRouter as Uniswap Router
    
    User->>MetaStake: claimAndSwap(池ID, 输出代币, 最小输出, 截止时间)
    
    MetaStake->>MetaStake: 检查Router是否设置
    alt Router未设置
        MetaStake-->>User: 交易失败: Uniswap router not set
    else Router已设置
        MetaStake->>MetaStake: 计算待领取奖励
        MetaStake->>MetaStake: 清零用户pendingMetaNode
        MetaStake->>MetaStake: 更新用户finishedMetaNode
        
        MetaStake->>MetaStake: 构建交换路径
        alt 交换成ETH
            MetaStake->>MetaStake: path = [MetaNode, WETH]
        else 交换成ERC20代币
            MetaStake->>MetaStake: path = [MetaNode, WETH, 目标代币]
        end
        
        MetaStake->>MetaNodeToken: approve(Router, 奖励数量)
        MetaNodeToken-->>MetaStake: 授权成功
        
        alt 交换成ETH
            MetaStake->>UniswapRouter: swapExactTokensForETH(奖励数量, 最小输出, 路径, 用户地址, 截止时间)
        else 交换成ERC20代币
            MetaStake->>UniswapRouter: swapExactTokensForTokens(奖励数量, 最小输出, 路径, 用户地址, 截止时间)
        end
        
        UniswapRouter->>MetaNodeToken: transferFrom(合约, Router, 奖励数量)
        MetaNodeToken-->>UniswapRouter: 转移成功
        
        alt 交换成ETH
            UniswapRouter->>User: 发送ETH
        else 交换成ERC20代币
            UniswapRouter->>User: 发送目标代币
        end
        
        UniswapRouter-->>MetaStake: 返回交换数量
        MetaStake->>MetaStake: 发出ClaimedAndSwapped事件
        MetaStake-->>User: 交换成功
    end
```



## 八、奖励分配机制

```mermaid
flowchart TD
    A[区块产生] --> B{当前区块 >= 开始区块?}
    B -->|否| C[不产生奖励]
    B -->|是| D[计算总奖励 = metaNodePerBlock]
    
    D --> E[遍历所有池]
    E --> F{池是否有质押?}
    F -->|无| G[跳过该池]
    F -->|有| H[计算池权重占比]
    
    H --> I[池奖励 = 总奖励 × 池权重 / 总权重]
    I --> J[更新池accMetaNodePerST]
    J --> K[更新池lastRewardBlock]
    
    G --> L{还有池?}
    K --> L
    L -->|是| E
    L -->|否| M[奖励分配完成]
    
    N[用户质押/解质押/领取时] --> O[调用updatePool]
    O --> P[更新当前池奖励]
    P --> Q[计算用户累积奖励]
    Q --> R[更新用户pendingMetaNode]
    
    style M fill:#c8e6c9
    style R fill:#e1f5ff
```

### 8.1.奖励计算公式

```
1.池奖励 = metaNodePerBlock × (池权重 / 所有池权重之和)
2.accMetaNodePerST += (池奖励 × 1e18) / 池总质押量
3.用户待领取奖励 = (用户质押量 × accMetaNodePerST) / 1e18 - 用户finishedMetaNode
```





## 九、池管理流程

```mermaid
flowchart TD
    A[管理员操作] --> B{操作类型}
    
    B -->|添加池| C[addPool]
    B -->|更新池配置| D[updatePoolConfig]
    
    C --> E{检查管理员权限}
    E -->|无权限| F[交易失败: AccessControl]
    E -->|有权限| G[创建新池结构]
    
    G --> H[设置池参数]
    H --> I[初始化池状态]
    I --> J[totalPools++]
    J --> K[发出PoolAdded事件]
    K --> L[池添加成功]
    
    D --> M{检查管理员权限}
    M -->|无权限| N[交易失败: AccessControl]
    M -->|有权限| O{检查池是否存在}
    
    O -->|不存在| P[交易失败: Pool does not exist]
    O -->|存在| Q[更新池配置参数]
    Q --> R[发出PoolUpdated事件]
    R --> S[池配置更新成功]
    
    style L fill:#c8e6c9
    style S fill:#c8e6c9
    style F fill:#ffcdd2
    style N fill:#ffcdd2
    style P fill:#ffcdd2
```



## 十、合约升级流程

```mermaid
sequenceDiagram
    participant Admin as 管理员(UPGRADER_ROLE)
    participant Proxy as UUPS代理合约
    participant OldImpl as 旧实现合约
    participant NewImpl as 新实现合约
    
    Admin->>NewImpl: 部署新实现合约
    NewImpl-->>Admin: 返回新实现地址
    
    Admin->>Proxy: upgradeToAndCall(新实现地址, 初始化数据)
    Proxy->>Proxy: 检查UPGRADER_ROLE权限
    
    alt 无权限
        Proxy-->>Admin: 交易失败: AccessControl
    else 有权限
        Proxy->>Proxy: 调用_authorizeUpgrade
        Proxy->>Proxy: 更新实现地址指向新合约
        Proxy->>NewImpl: 调用初始化函数(如果有)
        NewImpl-->>Proxy: 初始化完成
        Proxy-->>Admin: 升级成功
        
        Note over Proxy,NewImpl: 所有状态数据保留在代理合约中
        Note over Proxy,NewImpl: 只有逻辑代码更新到新实现
    end
```



## 十一、紧急操作流程

```mermaid
flowchart TD
    A[管理员紧急操作] --> B{操作类型}
    
    B -->|暂停功能| C[setPauseStatus]
    B -->|紧急提取| D[emergencyWithdraw]
    
    C --> E{检查管理员权限}
    E -->|无权限| F[交易失败: AccessControl]
    E -->|有权限| G{暂停类型}
    
    G -->|Stake| H[暂停质押功能]
    G -->|Unstake| I[暂停解质押功能]
    G -->|Claim| J[暂停领取奖励功能]
    
    H --> K[发出PauseStatusChanged事件]
    I --> K
    J --> K
    K --> L[暂停操作成功]
    
    D --> M{检查管理员权限}
    M -->|无权限| N[交易失败: AccessControl]
    M -->|有权限| O{代币类型}
    
    O -->|Native Currency| P[提取ETH到管理员地址]
    O -->|ERC20代币| Q[提取ERC20代币到管理员地址]
    
    P --> R[紧急提取成功]
    Q --> R
    
    style L fill:#fff9c4
    style R fill:#ffcdd2
    style F fill:#ffcdd2
    style N fill:#ffcdd2
```



## 十二、完整用户交互流程

```mermaid
stateDiagram-v2
    [*] --> 未质押
    
    未质押 --> 质押中: stake()
    质押中 --> 质押中: stake()多次质押
    质押中 --> 有奖励: 区块产生奖励
    有奖励 --> 领取奖励: claim()
    有奖励 --> 领取并交换: claimAndSwap()
    领取奖励 --> 质押中: 奖励已领取
    领取并交换 --> 质押中: 奖励已交换
    
    质押中 --> 解质押请求: unstake()
    解质押请求 --> 等待解锁: 创建请求
    等待解锁 --> 可提取: 锁定期结束
    可提取 --> 提取完成: withdraw()
    提取完成 --> 未质押: 全部提取
    提取完成 --> 质押中: 部分提取
    
    质押中 --> 未质押: emergencyWithdraw(管理员)
```



## 十三、数据流图

```mermaid
graph LR
    subgraph 用户层
        U1[用户A]
        U2[用户B]
        U3[用户C]
    end
    
    subgraph 合约层
        MS[MetaStake合约]
        MNT[MetaNode代币]
    end
    
    subgraph 池层
        P1[池0: ETH池]
        P2[池1: USDT池]
        P3[池2: WETH池]
    end
    
    subgraph 外部服务
        UR[Uniswap Router]
    end
    
    U1 -->|质押ETH| MS
    U2 -->|质押USDT| MS
    U3 -->|质押WETH| MS
    
    MS -->|存储| P1
    MS -->|存储| P2
    MS -->|存储| P3
    
    MS -->|分配奖励| MNT
    MNT -->|发放| U1
    MNT -->|发放| U2
    MNT -->|发放| U3
    
    MS -->|交换请求| UR
    UR -->|返回ETH/代币| U1
    UR -->|返回ETH/代币| U2
    UR -->|返回ETH/代币| U3
    
    style MS fill:#e1f5ff
    style MNT fill:#e8f5e9
    style UR fill:#f3e5f5
```





## 十四、关键函数调用关系

```mermaid
graph TD
    A[stake] --> B[updatePool]
    C[unstake] --> B
    D[claim] --> B
    E[claimAndSwap] --> B
    F[withdraw] --> G[检查解锁状态]
    
    B --> H[计算池奖励]
    B --> I[更新accMetaNodePerST]
    
    J[addPool] --> K[创建新池]
    L[updatePoolConfig] --> M[更新池参数]
    
    N[setUniswapRouter] --> O[设置Router地址]
    E --> P[调用Uniswap交换]
    
    Q[setPauseStatus] --> R[更新暂停状态]
    S[emergencyWithdraw] --> T[提取代币]
    
    U[upgradeToAndCall] --> V[升级合约]
    
    style B fill:#fff9c4
    style H fill:#e1f5ff
    style P fill:#f3e5f5
```



## 十五、权限控制矩阵

| 功能 | DEFAULT_ADMIN_ROLE | ADMIN_ROLE | UPGRADER_ROLE | 普通用户 |
|------|-------------------|------------|---------------|----------|
| 质押 | ✅ | ✅ | ✅ | ✅ |
| 解质押 | ✅ | ✅ | ✅ | ✅ |
| 领取奖励 | ✅ | ✅ | ✅ | ✅ |
| 添加池 | ✅ | ✅ | ❌ | ❌ |
| 更新池配置 | ✅ | ✅ | ❌ | ❌ |
| 设置Router | ✅ | ✅ | ❌ | ❌ |
| 暂停功能 | ✅ | ✅ | ❌ | ❌ |
| 紧急提取 | ✅ | ✅ | ❌ | ❌ |
| 升级合约 | ✅ | ❌ | ✅ | ❌ |
| 设置奖励率 | ✅ | ✅ | ❌ | ❌ |



## 十六、状态转换说明

### 16.1.用户状态转换

- **1.未质押 → 质押中**
  - 触发: `stake()`
  - 条件: 数量 >= 最小质押金额
  - 结果: `user.stAmount` 增加
- **2.质押中 → 有奖励**
  - 触发: 区块产生奖励
  - 条件: 区块 >= startBlock
  - 结果: `user.pendingMetaNode` 累积
- **3.有奖励 → 质押中**
  - 触发: `claim()` 或 `claimAndSwap()`
  - 条件: 有可领取奖励
  - 结果: 奖励已发放,`pendingMetaNode` 清零
- **4.质押中 → 解质押请求**
  - 触发: `unstake()`
  - 条件: 解质押数量 <= 质押数量
  - 结果: 创建 `UnstakeRequest`,等待解锁
- **5.解质押请求 → 可提取**
  - 触发: 区块号 >= unlockBlock
  - 条件: 锁定期结束
  - 结果: 可以调用 `withdraw()`
- **6.可提取 → 未质押/质押中**
  - 触发: `withdraw()`
  - 条件: 有可提取的请求
  - 结果: 代币返回用户,请求被移除



## 十七、注意事项

- **1.奖励计算时机**

  - 每次 `stake()`, `unstake()`, `claim()` 时自动调用 `updatePool()`
  - 确保奖励计算的实时性和准确性

- **2.锁定期机制**

  - 解质押后需要等待 `unstakeLockedBlocks` 个区块
  - 锁定期内无法提取,但可以继续质押和领取奖励

- **3.多池奖励分配**

  - 根据池权重按比例分配奖励
  - 权重越大,分配的奖励越多

- **4.Uniswap集成**

  - 需要先设置`Uniswap Router`地址
  - 交换时需要考虑滑点保护(`amountOutMin`)
  - 交换路径: `MetaNode` → `WETH` → 目标代币(如需要)

- **5.合约升级**

  - 使用`UUPS`代理模式,状态数据保留在代理合约中

  - 只有逻辑代码可以升级

  - 需要`UPGRADER_ROLE`权限



